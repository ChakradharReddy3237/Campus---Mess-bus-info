{"ast":null,"code":"// Advanced bus schedule parser for multi-category timetable text.\n// Expected categories: Working Days, Saturdays and M–F Holidays, Sundays.\n// Also captures Palakkad Town and Wise Park special routes (list of narrative entries).\n\nconst CATEGORY_LABELS = [{\n  key: 'working',\n  patterns: [/^working days/i]\n}, {\n  key: 'saturday',\n  patterns: [/^saturdays?\\b/i, /saturdays? and m.?–?f holidays/i]\n}, {\n  key: 'sunday',\n  patterns: [/^sundays?\\b/i]\n}];\nconst ROUTE_LINE_REGEX = /^(nila\\s*(to|→)\\s*sahyadri|sahyadri\\s*(to|→)\\s*nila)\\s*:/i;\nconst TIME_TOKEN = /(?:(?:[01]?\\d|2[0-3]):[0-5]\\d|(?:[1-9]|1[0-2]))(?:[:.]?[0-5]\\d)?/g; // matches 8:30, 8.45, 12, 12:15\n\n// Normalizes time tokens into HH:MM 24h or keeps as given with AM/PM inference not provided (source lacks AM/PM mostly).\nfunction normalizeTime(raw) {\n  let t = raw.trim();\n  t = t.replace(/\\./g, ':');\n  if (/^\\d{1,2}$/.test(t)) {\n    // lone hour, treat as H:00\n    t = t + ':00';\n  } else if (/^\\d{1,2}:\\d{1}$/.test(t)) {\n    const [h, m] = t.split(':');\n    t = h + ':' + m.padStart(2, '0');\n  }\n  // Ensure leading zero for hour < 10\n  const m = t.match(/^(\\d{1,2}):(\\d{2})$/);\n  if (m) {\n    const h = m[1].padStart(1, '0');\n    return `${h}:${m[2]}`;\n  }\n  return t;\n}\nexport function parseMultiCategoryBusText(text) {\n  const lines = text.split(/\\r?\\n/).map(l => l.trim()).filter(Boolean);\n  const categories = {};\n  let currentCat = null;\n  let inBusBlock = false;\n  let specialsCollector = [];\n  let specialsContext = null; // 'palakkadTown' | 'wisePark'\n\n  // Data structure:\n  // categories: { working: { routes: { \"Nila → Sahyadri\": [times], \"Sahyadri → Nila\": [times] } }, ... }\n  // specials: { palakkadTown: [string], wisePark: [string] }\n\n  const specials = {\n    palakkadTown: [],\n    wisePark: []\n  };\n  function ensureCat(key) {\n    if (!categories[key]) {\n      categories[key] = {\n        routes: {\n          'Nila → Sahyadri': [],\n          'Sahyadri → Nila': []\n        }\n      };\n    }\n  }\n  function commitSpecialLine(line) {\n    if (specialsContext === 'palakkadTown') specials.palakkadTown.push(line);\n    if (specialsContext === 'wisePark') specials.wisePark.push(line);\n  }\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n\n    // Detect category switches\n    const catMatch = CATEGORY_LABELS.find(c => c.patterns.some(p => p.test(line)));\n    if (catMatch) {\n      currentCat = catMatch.key;\n      ensureCat(currentCat);\n      inBusBlock = false;\n      specialsContext = null;\n      continue;\n    }\n\n    // Detect route lines for bus times\n    if (ROUTE_LINE_REGEX.test(line)) {\n      if (!currentCat) {\n        // default to working if not set when first route appears\n        currentCat = 'working';\n        ensureCat(currentCat);\n      }\n      inBusBlock = true;\n      specialsContext = null;\n      const [routeLabel, timesPartRaw] = line.split(/:/, 2);\n      const routeNorm = routeLabel.toLowerCase().includes('nila') && routeLabel.toLowerCase().includes('sahyadri') ? routeLabel.replace(/to/i, '→').replace(/\\s+/g, ' ').replace(/nila\\s*→?\\s*sahyadri/i, 'Nila → Sahyadri').replace(/sahyadri\\s*→?\\s*nila/i, 'Sahyadri → Nila') : routeLabel;\n      const route = routeNorm.includes('Sahyadri → Nila') ? 'Sahyadri → Nila' : 'Nila → Sahyadri';\n      const timesInline = timesPartRaw ? timesPartRaw : '';\n      const subsequent = [];\n      // Collect following lines that are continuation (no colon, contain time tokens) until blank or new section\n      for (let j = i + 1; j < lines.length; j++) {\n        const nxt = lines[j];\n        if (!nxt) break;\n        if (ROUTE_LINE_REGEX.test(nxt)) break;\n        if (/^(palakkad town)/i.test(nxt) || /wise park junction/i.test(nxt) || CATEGORY_LABELS.some(c => c.patterns.some(p => p.test(nxt)))) break;\n        if (/^\\*/.test(nxt)) continue; // skip notes line\n        if (nxt.includes(':') && !TIME_TOKEN.test(nxt)) break; // looks like narrative with a colon but not times\n        subsequent.push(nxt);\n        i = j; // advance outer loop\n      }\n      const merged = [timesInline, ...subsequent].join(' ');\n      const rawTimes = merged.match(TIME_TOKEN) || [];\n      const normTimes = rawTimes.map(normalizeTime);\n      ensureCat(currentCat);\n      categories[currentCat].routes[route] = normTimes;\n      continue;\n    }\n\n    // Specials contexts\n    if (/^palakkad town/i.test(line)) {\n      specialsContext = 'palakkadTown';\n      continue;\n    }\n    if (/wise park junction/i.test(line)) {\n      specialsContext = 'wisePark';\n      continue;\n    }\n\n    // Collect bullet / numbered lines under specials\n    if (specialsContext) {\n      commitSpecialLine(line.replace(/^\\d+\\.\\s*/, ''));\n      continue;\n    }\n  }\n  return {\n    categories,\n    specials\n  };\n}","map":{"version":3,"names":["CATEGORY_LABELS","key","patterns","ROUTE_LINE_REGEX","TIME_TOKEN","normalizeTime","raw","t","trim","replace","test","h","m","split","padStart","match","parseMultiCategoryBusText","text","lines","map","l","filter","Boolean","categories","currentCat","inBusBlock","specialsCollector","specialsContext","specials","palakkadTown","wisePark","ensureCat","routes","commitSpecialLine","line","push","i","length","catMatch","find","c","some","p","routeLabel","timesPartRaw","routeNorm","toLowerCase","includes","route","timesInline","subsequent","j","nxt","merged","join","rawTimes","normTimes"],"sources":["/home/chakri/Documents/Projects/Website/src/utils/busParser.js"],"sourcesContent":["// Advanced bus schedule parser for multi-category timetable text.\n// Expected categories: Working Days, Saturdays and M–F Holidays, Sundays.\n// Also captures Palakkad Town and Wise Park special routes (list of narrative entries).\n\nconst CATEGORY_LABELS = [\n  { key: 'working', patterns: [/^working days/i] },\n  { key: 'saturday', patterns: [/^saturdays?\\b/i, /saturdays? and m.?–?f holidays/i] },\n  { key: 'sunday', patterns: [/^sundays?\\b/i] }\n];\n\nconst ROUTE_LINE_REGEX = /^(nila\\s*(to|→)\\s*sahyadri|sahyadri\\s*(to|→)\\s*nila)\\s*:/i;\nconst TIME_TOKEN = /(?:(?:[01]?\\d|2[0-3]):[0-5]\\d|(?:[1-9]|1[0-2]))(?:[:.]?[0-5]\\d)?/g; // matches 8:30, 8.45, 12, 12:15\n\n// Normalizes time tokens into HH:MM 24h or keeps as given with AM/PM inference not provided (source lacks AM/PM mostly).\nfunction normalizeTime(raw) {\n  let t = raw.trim();\n  t = t.replace(/\\./g, ':');\n  if (/^\\d{1,2}$/.test(t)) {\n    // lone hour, treat as H:00\n    t = t + ':00';\n  } else if (/^\\d{1,2}:\\d{1}$/.test(t)) {\n    const [h, m] = t.split(':');\n    t = h + ':' + m.padStart(2, '0');\n  }\n  // Ensure leading zero for hour < 10\n  const m = t.match(/^(\\d{1,2}):(\\d{2})$/);\n  if (m) {\n    const h = m[1].padStart(1, '0');\n    return `${h}:${m[2]}`;\n  }\n  return t;\n}\n\nexport function parseMultiCategoryBusText(text) {\n  const lines = text.split(/\\r?\\n/).map(l => l.trim()).filter(Boolean);\n  const categories = {};\n  let currentCat = null;\n  let inBusBlock = false;\n  let specialsCollector = [];\n  let specialsContext = null; // 'palakkadTown' | 'wisePark'\n\n  // Data structure:\n  // categories: { working: { routes: { \"Nila → Sahyadri\": [times], \"Sahyadri → Nila\": [times] } }, ... }\n  // specials: { palakkadTown: [string], wisePark: [string] }\n\n  const specials = { palakkadTown: [], wisePark: [] };\n\n  function ensureCat(key) {\n    if (!categories[key]) {\n      categories[key] = { routes: { 'Nila → Sahyadri': [], 'Sahyadri → Nila': [] } };\n    }\n  }\n\n  function commitSpecialLine(line) {\n    if (specialsContext === 'palakkadTown') specials.palakkadTown.push(line);\n    if (specialsContext === 'wisePark') specials.wisePark.push(line);\n  }\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n\n    // Detect category switches\n    const catMatch = CATEGORY_LABELS.find(c => c.patterns.some(p => p.test(line)));\n    if (catMatch) {\n      currentCat = catMatch.key;\n      ensureCat(currentCat);\n      inBusBlock = false;\n      specialsContext = null;\n      continue;\n    }\n\n    // Detect route lines for bus times\n    if (ROUTE_LINE_REGEX.test(line)) {\n      if (!currentCat) {\n        // default to working if not set when first route appears\n        currentCat = 'working';\n        ensureCat(currentCat);\n      }\n      inBusBlock = true;\n      specialsContext = null;\n\n      const [routeLabel, timesPartRaw] = line.split(/:/, 2);\n      const routeNorm = routeLabel.toLowerCase().includes('nila') && routeLabel.toLowerCase().includes('sahyadri')\n        ? routeLabel\n            .replace(/to/i, '→')\n            .replace(/\\s+/g, ' ')\n            .replace(/nila\\s*→?\\s*sahyadri/i, 'Nila → Sahyadri')\n            .replace(/sahyadri\\s*→?\\s*nila/i, 'Sahyadri → Nila')\n        : routeLabel;\n      const route = routeNorm.includes('Sahyadri → Nila') ? 'Sahyadri → Nila' : 'Nila → Sahyadri';\n      const timesInline = timesPartRaw ? timesPartRaw : '';\n      const subsequent = [];\n      // Collect following lines that are continuation (no colon, contain time tokens) until blank or new section\n      for (let j = i + 1; j < lines.length; j++) {\n        const nxt = lines[j];\n        if (!nxt) break;\n        if (ROUTE_LINE_REGEX.test(nxt)) break;\n        if (/^(palakkad town)/i.test(nxt) || /wise park junction/i.test(nxt) || CATEGORY_LABELS.some(c => c.patterns.some(p => p.test(nxt)))) break;\n        if (/^\\*/.test(nxt)) continue; // skip notes line\n        if (nxt.includes(':') && !TIME_TOKEN.test(nxt)) break; // looks like narrative with a colon but not times\n        subsequent.push(nxt);\n        i = j; // advance outer loop\n      }\n      const merged = [timesInline, ...subsequent].join(' ');\n      const rawTimes = merged.match(TIME_TOKEN) || [];\n      const normTimes = rawTimes.map(normalizeTime);\n      ensureCat(currentCat);\n      categories[currentCat].routes[route] = normTimes;\n      continue;\n    }\n\n    // Specials contexts\n    if (/^palakkad town/i.test(line)) {\n      specialsContext = 'palakkadTown';\n      continue;\n    }\n    if (/wise park junction/i.test(line)) {\n      specialsContext = 'wisePark';\n      continue;\n    }\n\n    // Collect bullet / numbered lines under specials\n    if (specialsContext) {\n      commitSpecialLine(line.replace(/^\\d+\\.\\s*/, ''));\n      continue;\n    }\n  }\n\n  return { categories, specials };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}