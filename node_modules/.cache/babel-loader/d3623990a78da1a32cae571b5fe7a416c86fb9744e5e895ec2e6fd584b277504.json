{"ast":null,"code":"// Advanced bus schedule parser for multi-category timetable text.\n// Expected categories: Working Days, Saturdays and M–F Holidays, Sundays.\n// Also captures Palakkad Town and Wise Park special routes (list of narrative entries).\nconst CATEGORY_LABELS=[{key:'working',patterns:[/^working days/i]},{key:'saturday',patterns:[/^saturdays?\\b/i,/saturdays? and m.?–?f holidays/i]},{key:'sunday',patterns:[/^sundays?\\b/i]}];const ROUTE_LINE_REGEX=/^(nila\\s*(to|→)\\s*sahyadri|sahyadri\\s*(to|→)\\s*nila)\\s*:/i;const TIME_TOKEN=/(?:(?:[01]?\\d|2[0-3]):[0-5]\\d|(?:[1-9]|1[0-2]))(?:[:.]?[0-5]\\d)?/g;// matches 8:30, 8.45, 12, 12:15\n// Normalizes time tokens into HH:MM 24h or keeps as given with AM/PM inference not provided (source lacks AM/PM mostly).\nfunction normalizeTime(raw){let t=raw.trim();t=t.replace(/\\./g,':');if(/^\\d{1,2}$/.test(t)){// lone hour, treat as H:00\nt=t+':00';}else if(/^\\d{1,2}:\\d{1}$/.test(t)){const[h,m]=t.split(':');t=h+':'+m.padStart(2,'0');}// Ensure leading zero for hour < 10\nconst m=t.match(/^(\\d{1,2}):(\\d{2})$/);if(m){const h=m[1].padStart(1,'0');return\"\".concat(h,\":\").concat(m[2]);}return t;}export function parseMultiCategoryBusText(text){const lines=text.split(/\\r?\\n/).map(l=>l.trim()).filter(Boolean);const categories={};let currentCat=null;let inBusBlock=false;let specialsCollector=[];let specialsContext=null;// 'palakkadTown' | 'wisePark'\n// Data structure:\n// categories: { working: { routes: { \"Nila → Sahyadri\": [times], \"Sahyadri → Nila\": [times] } }, ... }\n// specials: { palakkadTown: [string], wisePark: [string] }\nconst specials={palakkadTown:[],wisePark:[]};function ensureCat(key){if(!categories[key]){categories[key]={routes:{'Nila → Sahyadri':[],'Sahyadri → Nila':[]}};}}function commitSpecialLine(line){if(specialsContext==='palakkadTown')specials.palakkadTown.push(line);if(specialsContext==='wisePark')specials.wisePark.push(line);}for(let i=0;i<lines.length;i++){const line=lines[i];// Detect category switches\nconst catMatch=CATEGORY_LABELS.find(c=>c.patterns.some(p=>p.test(line)));if(catMatch){currentCat=catMatch.key;ensureCat(currentCat);inBusBlock=false;specialsContext=null;continue;}// Detect route lines for bus times\nif(ROUTE_LINE_REGEX.test(line)){if(!currentCat){// default to working if not set when first route appears\ncurrentCat='working';ensureCat(currentCat);}inBusBlock=true;specialsContext=null;const[routeLabel,timesPartRaw]=line.split(/:/,2);const routeNorm=routeLabel.toLowerCase().includes('nila')&&routeLabel.toLowerCase().includes('sahyadri')?routeLabel.replace(/to/i,'→').replace(/\\s+/g,' ').replace(/nila\\s*→?\\s*sahyadri/i,'Nila → Sahyadri').replace(/sahyadri\\s*→?\\s*nila/i,'Sahyadri → Nila'):routeLabel;const route=routeNorm.includes('Sahyadri → Nila')?'Sahyadri → Nila':'Nila → Sahyadri';const timesInline=timesPartRaw?timesPartRaw:'';const subsequent=[];// Collect following lines that are continuation (no colon, contain time tokens) until blank or new section\nfor(let j=i+1;j<lines.length;j++){const nxt=lines[j];if(!nxt)break;if(ROUTE_LINE_REGEX.test(nxt))break;if(/^(palakkad town)/i.test(nxt)||/wise park junction/i.test(nxt)||CATEGORY_LABELS.some(c=>c.patterns.some(p=>p.test(nxt))))break;if(/^\\*/.test(nxt))continue;// skip notes line\nif(nxt.includes(':')&&!TIME_TOKEN.test(nxt))break;// looks like narrative with a colon but not times\nsubsequent.push(nxt);i=j;// advance outer loop\n}const merged=[timesInline,...subsequent].join(' ');const rawTimes=merged.match(TIME_TOKEN)||[];const normTimes=rawTimes.map(normalizeTime);ensureCat(currentCat);categories[currentCat].routes[route]=normTimes;continue;}// Specials contexts\nif(/^palakkad town/i.test(line)){specialsContext='palakkadTown';continue;}if(/wise park junction/i.test(line)){specialsContext='wisePark';continue;}// Collect bullet / numbered lines under specials\nif(specialsContext){commitSpecialLine(line.replace(/^\\d+\\.\\s*/,''));continue;}}return{categories,specials};}","map":{"version":3,"names":["CATEGORY_LABELS","key","patterns","ROUTE_LINE_REGEX","TIME_TOKEN","normalizeTime","raw","t","trim","replace","test","h","m","split","padStart","match","concat","parseMultiCategoryBusText","text","lines","map","l","filter","Boolean","categories","currentCat","inBusBlock","specialsCollector","specialsContext","specials","palakkadTown","wisePark","ensureCat","routes","commitSpecialLine","line","push","i","length","catMatch","find","c","some","p","routeLabel","timesPartRaw","routeNorm","toLowerCase","includes","route","timesInline","subsequent","j","nxt","merged","join","rawTimes","normTimes"],"sources":["/home/chakri/Documents/Projects/Website/src/utils/busParser.js"],"sourcesContent":["// Advanced bus schedule parser for multi-category timetable text.\n// Expected categories: Working Days, Saturdays and M–F Holidays, Sundays.\n// Also captures Palakkad Town and Wise Park special routes (list of narrative entries).\n\nconst CATEGORY_LABELS = [\n  { key: 'working', patterns: [/^working days/i] },\n  { key: 'saturday', patterns: [/^saturdays?\\b/i, /saturdays? and m.?–?f holidays/i] },\n  { key: 'sunday', patterns: [/^sundays?\\b/i] }\n];\n\nconst ROUTE_LINE_REGEX = /^(nila\\s*(to|→)\\s*sahyadri|sahyadri\\s*(to|→)\\s*nila)\\s*:/i;\nconst TIME_TOKEN = /(?:(?:[01]?\\d|2[0-3]):[0-5]\\d|(?:[1-9]|1[0-2]))(?:[:.]?[0-5]\\d)?/g; // matches 8:30, 8.45, 12, 12:15\n\n// Normalizes time tokens into HH:MM 24h or keeps as given with AM/PM inference not provided (source lacks AM/PM mostly).\nfunction normalizeTime(raw) {\n  let t = raw.trim();\n  t = t.replace(/\\./g, ':');\n  if (/^\\d{1,2}$/.test(t)) {\n    // lone hour, treat as H:00\n    t = t + ':00';\n  } else if (/^\\d{1,2}:\\d{1}$/.test(t)) {\n    const [h, m] = t.split(':');\n    t = h + ':' + m.padStart(2, '0');\n  }\n  // Ensure leading zero for hour < 10\n  const m = t.match(/^(\\d{1,2}):(\\d{2})$/);\n  if (m) {\n    const h = m[1].padStart(1, '0');\n    return `${h}:${m[2]}`;\n  }\n  return t;\n}\n\nexport function parseMultiCategoryBusText(text) {\n  const lines = text.split(/\\r?\\n/).map(l => l.trim()).filter(Boolean);\n  const categories = {};\n  let currentCat = null;\n  let inBusBlock = false;\n  let specialsCollector = [];\n  let specialsContext = null; // 'palakkadTown' | 'wisePark'\n\n  // Data structure:\n  // categories: { working: { routes: { \"Nila → Sahyadri\": [times], \"Sahyadri → Nila\": [times] } }, ... }\n  // specials: { palakkadTown: [string], wisePark: [string] }\n\n  const specials = { palakkadTown: [], wisePark: [] };\n\n  function ensureCat(key) {\n    if (!categories[key]) {\n      categories[key] = { routes: { 'Nila → Sahyadri': [], 'Sahyadri → Nila': [] } };\n    }\n  }\n\n  function commitSpecialLine(line) {\n    if (specialsContext === 'palakkadTown') specials.palakkadTown.push(line);\n    if (specialsContext === 'wisePark') specials.wisePark.push(line);\n  }\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i];\n\n    // Detect category switches\n    const catMatch = CATEGORY_LABELS.find(c => c.patterns.some(p => p.test(line)));\n    if (catMatch) {\n      currentCat = catMatch.key;\n      ensureCat(currentCat);\n      inBusBlock = false;\n      specialsContext = null;\n      continue;\n    }\n\n    // Detect route lines for bus times\n    if (ROUTE_LINE_REGEX.test(line)) {\n      if (!currentCat) {\n        // default to working if not set when first route appears\n        currentCat = 'working';\n        ensureCat(currentCat);\n      }\n      inBusBlock = true;\n      specialsContext = null;\n\n      const [routeLabel, timesPartRaw] = line.split(/:/, 2);\n      const routeNorm = routeLabel.toLowerCase().includes('nila') && routeLabel.toLowerCase().includes('sahyadri')\n        ? routeLabel\n            .replace(/to/i, '→')\n            .replace(/\\s+/g, ' ')\n            .replace(/nila\\s*→?\\s*sahyadri/i, 'Nila → Sahyadri')\n            .replace(/sahyadri\\s*→?\\s*nila/i, 'Sahyadri → Nila')\n        : routeLabel;\n      const route = routeNorm.includes('Sahyadri → Nila') ? 'Sahyadri → Nila' : 'Nila → Sahyadri';\n      const timesInline = timesPartRaw ? timesPartRaw : '';\n      const subsequent = [];\n      // Collect following lines that are continuation (no colon, contain time tokens) until blank or new section\n      for (let j = i + 1; j < lines.length; j++) {\n        const nxt = lines[j];\n        if (!nxt) break;\n        if (ROUTE_LINE_REGEX.test(nxt)) break;\n        if (/^(palakkad town)/i.test(nxt) || /wise park junction/i.test(nxt) || CATEGORY_LABELS.some(c => c.patterns.some(p => p.test(nxt)))) break;\n        if (/^\\*/.test(nxt)) continue; // skip notes line\n        if (nxt.includes(':') && !TIME_TOKEN.test(nxt)) break; // looks like narrative with a colon but not times\n        subsequent.push(nxt);\n        i = j; // advance outer loop\n      }\n      const merged = [timesInline, ...subsequent].join(' ');\n      const rawTimes = merged.match(TIME_TOKEN) || [];\n      const normTimes = rawTimes.map(normalizeTime);\n      ensureCat(currentCat);\n      categories[currentCat].routes[route] = normTimes;\n      continue;\n    }\n\n    // Specials contexts\n    if (/^palakkad town/i.test(line)) {\n      specialsContext = 'palakkadTown';\n      continue;\n    }\n    if (/wise park junction/i.test(line)) {\n      specialsContext = 'wisePark';\n      continue;\n    }\n\n    // Collect bullet / numbered lines under specials\n    if (specialsContext) {\n      commitSpecialLine(line.replace(/^\\d+\\.\\s*/, ''));\n      continue;\n    }\n  }\n\n  return { categories, specials };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}