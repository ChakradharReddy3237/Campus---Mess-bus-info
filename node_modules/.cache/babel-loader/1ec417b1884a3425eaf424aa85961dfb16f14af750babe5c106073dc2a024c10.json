{"ast":null,"code":"// Data model\n// {\n//   menu: { breakfast: string, lunch: string, snacks: string, dinner: string },\n//   buses: { routes: [{ route: string, times: string[] }] }\n// }\n\nconst titleAliases = {\n  breakfast: ['breakfast', 'bf'],\n  lunch: ['lunch'],\n  snacks: ['snacks', 'tiffin', 'snack'],\n  dinner: ['dinner', 'supper']\n};\nconst findKey = line => {\n  const lower = line.toLowerCase();\n  for (const [key, aliases] of Object.entries(titleAliases)) {\n    if (aliases.some(a => lower.startsWith(a + ':'))) return key;\n  }\n  return null;\n};\nfunction parseMenu(lines) {\n  const menu = {\n    breakfast: '',\n    lunch: '',\n    snacks: '',\n    dinner: ''\n  };\n  lines.forEach(line => {\n    const key = findKey(line);\n    if (key) {\n      const val = line.split(':').slice(1).join(':').trim();\n      menu[key] = val;\n    }\n  });\n  return menu;\n}\nfunction parseBuses(lines) {\n  const routes = [];\n  const arrowRegex = /\\s*(→|->|to)\\s*/i;\n  const timeRegex = /((1[0-2]|0?[1-9]):[0-5][0-9]\\s?(AM|PM))/ig;\n  lines.forEach(line => {\n    if (!line.trim()) return;\n    // Format: Route A → Route B: 9:00 PM, 10:00 PM\n    const parts = line.split(':');\n    if (parts.length < 2) return;\n    const routeRaw = parts[0].trim();\n    const timesRaw = parts.slice(1).join(':');\n    const [from, to] = routeRaw.split(arrowRegex).filter(Boolean);\n    if (!from || !to) return;\n    const route = `${from.trim()} → ${to.trim()}`;\n    const times = [];\n    const matches = timesRaw.match(timeRegex);\n    if (matches) {\n      matches.forEach(t => times.push(t.toUpperCase().replace(/\\s+/g, ' ').trim()));\n    }\n    if (times.length) routes.push({\n      route,\n      times\n    });\n  });\n  return {\n    routes\n  };\n}\nexport function parseAllFromText(text, fallback) {\n  var _fallback$buses;\n  if (!text || !text.trim()) return fallback || null;\n\n  // If user pasted JSON in our shape, just trust it.\n  try {\n    const obj = JSON.parse(text);\n    if (obj && obj.menu && obj.buses) return obj;\n  } catch {}\n  const lines = text.split(/\\r?\\n/).map(l => l.trim()).filter(Boolean);\n\n  // Split sections heuristically: until we meet a line starting with buses or looks like a route\n  const busStartIdx = lines.findIndex(l => /^(buses|bus)[:\\s]/i.test(l) || /(→|->|to)/i.test(l));\n  const menuLines = busStartIdx === -1 ? lines : lines.slice(0, busStartIdx);\n  const busLines = busStartIdx === -1 ? [] : lines.slice(busStartIdx).filter(l => !/^buses[:\\s]?$/i.test(l));\n  const menu = parseMenu(menuLines);\n  const buses = parseBuses(busLines);\n\n  // Merge with fallback so missing keys are preserved\n  const out = {\n    menu: {\n      ...((fallback === null || fallback === void 0 ? void 0 : fallback.menu) || {}),\n      ...menu\n    },\n    buses: {\n      routes: buses.routes.length ? buses.routes : (fallback === null || fallback === void 0 ? void 0 : (_fallback$buses = fallback.buses) === null || _fallback$buses === void 0 ? void 0 : _fallback$buses.routes) || []\n    }\n  };\n  return out;\n}","map":{"version":3,"names":["titleAliases","breakfast","lunch","snacks","dinner","findKey","line","lower","toLowerCase","key","aliases","Object","entries","some","a","startsWith","parseMenu","lines","menu","forEach","val","split","slice","join","trim","parseBuses","routes","arrowRegex","timeRegex","parts","length","routeRaw","timesRaw","from","to","filter","Boolean","route","times","matches","match","t","push","toUpperCase","replace","parseAllFromText","text","fallback","_fallback$buses","obj","JSON","parse","buses","map","l","busStartIdx","findIndex","test","menuLines","busLines","out"],"sources":["/home/chakri/Documents/Projects/Website/src/utils/parser.js"],"sourcesContent":["// Data model\n// {\n//   menu: { breakfast: string, lunch: string, snacks: string, dinner: string },\n//   buses: { routes: [{ route: string, times: string[] }] }\n// }\n\nconst titleAliases = {\n  breakfast: ['breakfast', 'bf'],\n  lunch: ['lunch'],\n  snacks: ['snacks', 'tiffin', 'snack'],\n  dinner: ['dinner', 'supper'],\n};\n\nconst findKey = (line) => {\n  const lower = line.toLowerCase();\n  for (const [key, aliases] of Object.entries(titleAliases)) {\n    if (aliases.some((a) => lower.startsWith(a + ':'))) return key;\n  }\n  return null;\n};\n\nfunction parseMenu(lines) {\n  const menu = { breakfast: '', lunch: '', snacks: '', dinner: '' };\n  lines.forEach((line) => {\n    const key = findKey(line);\n    if (key) {\n      const val = line.split(':').slice(1).join(':').trim();\n      menu[key] = val;\n    }\n  });\n  return menu;\n}\n\nfunction parseBuses(lines) {\n  const routes = [];\n  const arrowRegex = /\\s*(→|->|to)\\s*/i;\n  const timeRegex = /((1[0-2]|0?[1-9]):[0-5][0-9]\\s?(AM|PM))/ig;\n\n  lines.forEach((line) => {\n    if (!line.trim()) return;\n    // Format: Route A → Route B: 9:00 PM, 10:00 PM\n    const parts = line.split(':');\n    if (parts.length < 2) return;\n    const routeRaw = parts[0].trim();\n    const timesRaw = parts.slice(1).join(':');\n    const [from, to] = routeRaw.split(arrowRegex).filter(Boolean);\n    if (!from || !to) return;\n    const route = `${from.trim()} → ${to.trim()}`;\n    const times = [];\n    const matches = timesRaw.match(timeRegex);\n    if (matches) {\n      matches.forEach((t) => times.push(t.toUpperCase().replace(/\\s+/g, ' ').trim()));\n    }\n    if (times.length) routes.push({ route, times });\n  });\n\n  return { routes };\n}\n\nexport function parseAllFromText(text, fallback) {\n  if (!text || !text.trim()) return fallback || null;\n\n  // If user pasted JSON in our shape, just trust it.\n  try {\n    const obj = JSON.parse(text);\n    if (obj && obj.menu && obj.buses) return obj;\n  } catch {}\n\n  const lines = text\n    .split(/\\r?\\n/)\n    .map((l) => l.trim())\n    .filter(Boolean);\n\n  // Split sections heuristically: until we meet a line starting with buses or looks like a route\n  const busStartIdx = lines.findIndex((l) => /^(buses|bus)[:\\s]/i.test(l) || /(→|->|to)/i.test(l));\n\n  const menuLines = busStartIdx === -1 ? lines : lines.slice(0, busStartIdx);\n  const busLines = busStartIdx === -1 ? [] : lines.slice(busStartIdx).filter((l) => !/^buses[:\\s]?$/i.test(l));\n\n  const menu = parseMenu(menuLines);\n  const buses = parseBuses(busLines);\n\n  // Merge with fallback so missing keys are preserved\n  const out = {\n    menu: { ...(fallback?.menu || {}), ...menu },\n    buses: { routes: buses.routes.length ? buses.routes : (fallback?.buses?.routes || []) },\n  };\n  return out;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}